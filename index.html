<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlas Chess</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Stockfish 16 (open-source engine, UCI over WebWorker) -->
    <script>
        // preload by creating a dummy worker so the CDN fetch is cached before React mounts
        const __stockfishPreload = new Worker('https://cdn.jsdelivr.net/npm/stockfish@16.0.0/src/stockfish-nnue-16-single.js');
        __stockfishPreload.postMessage('uci');
        __stockfishPreload.onmessage = () => {
            __stockfishPreload.terminate();
        };
    </script>
    <link href="https://cdn.jsdelivr.net/npm/lucide-static@0.321.0/font/lucide.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; }

        @keyframes pieceMove {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        @keyframes highlightSquare {
            0% { background-color: transparent; }
            50% { background-color: rgba(251, 191, 36, 0.3); }
            100% { background-color: transparent; }
        }

        .piece-animation {
            animation: pieceMove 0.3s ease-in-out;
        }

        .square-highlight {
            animation: highlightSquare 0.5s ease-in-out;
        }
    </style>
</head>
<body class="bg-slate-950">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // Supabase Configuration
        const SUPABASE_URL = 'https://aehjzqyhgjdprcoqznbo.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFlaGp6cXloZ2pkcHJjb3F6bmJvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkzMDExNDcsImV4cCI6MjA4NDg3NzE0N30.u_NT_QXmnEo8uYCmr3yHaGVHMA6I5YbP81o04tSFaOM';
        const { createClient } = window.supabase;
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        const Icon = ({ name, size = 20, className = "" }) => (
            <i className={`lucide-${name} ${className}`} style={{ fontSize: size }} />
        );

        const files = ['a','b','c','d','e','f','g','h'];
        const pieceIcons = {
            w: { p: '‚ôô', r: '‚ôñ', n: '‚ôò', b: '‚ôó', q: '‚ôï', k: '‚ôî' },
            b: { p: '‚ôü', r: '‚ôú', n: '‚ôû', b: '‚ôù', q: '‚ôõ', k: '‚ôö' }
        };

        const squareName = (r, c) => `${files[c]}${8 - r}`;

        const formatStatus = (status) => {
            if (status.startsWith('checkmate')) return status.replace('checkmate_', 'Checkmate: ');
            if (status === 'draw') return 'Draw';
            return 'Playing';
        };

        const applyMoveString = (game, moveStr) => {
            if (!moveStr) return null;
            const from = moveStr.slice(0, 2);
            const to = moveStr.slice(2, 4);
            const promotion = moveStr[4] || undefined;
            return game.move({ from, to, promotion });
        };

        const ChessGame = () => {
            const gameRef = useRef(new Chess());
            const engineRef = useRef(null);
            const [board, setBoard] = useState(gameRef.current.board());
            const [turn, setTurn] = useState(gameRef.current.turn());
            const [selectedSquare, setSelectedSquare] = useState(null);
            const [validMoves, setValidMoves] = useState([]);
            const [gameStatus, setGameStatus] = useState('playing');
            const [mode, setMode] = useState('ai'); // 'ai' or 'human'
            const [aiSide, setAiSide] = useState('b');
            const [aiDepth, setAiDepth] = useState(3);
            const [aiThinking, setAiThinking] = useState(false);
            const [engineReady, setEngineReady] = useState(false);
            const [engineError, setEngineError] = useState(null);
            const [hintMove, setHintMove] = useState(null);
            const [leaderboard, setLeaderboard] = useState([]);
            const [loadingLeaderboard, setLoadingLeaderboard] = useState(true);
            const [moveHistory, setMoveHistory] = useState([]);
            const [flipped, setFlipped] = useState(false);
            const [lastMove, setLastMove] = useState(null);
            const [capturedPieces, setCapturedPieces] = useState({ w: [], b: [] });
            const [promotionDialog, setPromotionDialog] = useState(null);
            const [soundEnabled, setSoundEnabled] = useState(true);


            const playSound = (type) => {
                if (!soundEnabled) return;
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                if (type === 'move') {
                    oscillator.frequency.value = 440;
                    gainNode.gain.value = 0.1;
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                } else if (type === 'capture') {
                    oscillator.frequency.value = 330;
                    gainNode.gain.value = 0.15;
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                }
            };

            const calculateCapturedPieces = () => {
                const game = gameRef.current;
                const currentPieces = { w: { p: 0, r: 0, n: 0, b: 0, q: 0 }, b: { p: 0, r: 0, n: 0, b: 0, q: 0 } };
                game.board().forEach(row => {
                    row.forEach(piece => {
                        if (piece) currentPieces[piece.color][piece.type]++;
                    });
                });
                const startingPieces = { p: 8, r: 2, n: 2, b: 2, q: 1 };
                const captured = { w: [], b: [] };
                ['p', 'r', 'n', 'b', 'q'].forEach(type => {
                    const wMissing = startingPieces[type] - currentPieces.w[type];
                    const bMissing = startingPieces[type] - currentPieces.b[type];
                    for (let i = 0; i < wMissing; i++) captured.b.push(type);
                    for (let i = 0; i < bMissing; i++) captured.w.push(type);
                });
                setCapturedPieces(captured);
            };

            const syncState = () => {
                const game = gameRef.current;
                setBoard(game.board());
                setTurn(game.turn());
                setMoveHistory(game.history());
                calculateCapturedPieces();
                if (game.in_checkmate()) {
                    const winner = game.turn() === 'w' ? 'Black' : 'White';
                    setGameStatus(`checkmate_${winner.toLowerCase()}`);
                    updateLeaderboard(winner);
                } else if (game.in_stalemate() || game.in_draw()) {
                    setGameStatus('draw');
                } else {
                    setGameStatus('playing');
                }
            };

            const updateLeaderboard = async (winner) => {
                const entry = {
                    winner,
                    mode,
                    ai_side: aiSide === 'w' ? 'White' : 'Black',
                    depth: aiDepth,
                    moves: gameRef.current.history().length,
                    game_history: gameRef.current.history(),
                    fen: gameRef.current.fen(),
                    created_at: new Date().toISOString()
                };

                // Save to Supabase if configured
                if (SUPABASE_URL !== 'YOUR_SUPABASE_URL') {
                    try {
                        const { error } = await supabase
                            .from('chess_games')
                            .insert([entry]);

                        if (error) console.error('Error saving to Supabase:', error);
                        else loadLeaderboard(); // Refresh leaderboard
                    } catch (err) {
                        console.error('Supabase error:', err);
                    }
                } else {
                    // Fallback to localStorage
                    const saved = localStorage.getItem('chess_leaderboard');
                    const current = saved ? JSON.parse(saved) : [];
                    const next = [{ ...entry, date: new Date().toLocaleString() }, ...current].slice(0, 50);
                    setLeaderboard(next);
                    localStorage.setItem('chess_leaderboard', JSON.stringify(next));
                }
            };

            const loadLeaderboard = async () => {
                if (SUPABASE_URL !== 'YOUR_SUPABASE_URL') {
                    try {
                        const { data, error } = await supabase
                            .from('chess_games')
                            .select('*')
                            .order('created_at', { ascending: false })
                            .limit(50);

                        if (error) {
                            console.error('Error loading from Supabase:', error);
                            loadLocalLeaderboard();
                        } else {
                            setLeaderboard(data || []);
                        }
                    } catch (err) {
                        console.error('Supabase error:', err);
                        loadLocalLeaderboard();
                    }
                } else {
                    loadLocalLeaderboard();
                }
                setLoadingLeaderboard(false);
            };

            const loadLocalLeaderboard = () => {
                const saved = localStorage.getItem('chess_leaderboard');
                setLeaderboard(saved ? JSON.parse(saved) : []);
            };

            const isHumanTurn = mode === 'human' || gameRef.current.turn() !== aiSide;

            const resetGame = () => {
                gameRef.current = new Chess();
                setSelectedSquare(null);
                setValidMoves([]);
                setHintMove(null);
                setAiThinking(false);
                setLastMove(null);
                setCapturedPieces({ w: [], b: [] });
                setPromotionDialog(null);
                syncState();
            };

            const resign = () => {
                if (gameStatus !== 'playing') return;
                const winner = gameRef.current.turn() === 'w' ? 'Black' : 'White';
                setGameStatus(`checkmate_${winner.toLowerCase()}`);
                updateLeaderboard(winner);
            };

            const handleSquareClick = (square) => {
                if (gameStatus !== 'playing' || aiThinking || !isHumanTurn) return;
                const game = gameRef.current;
                if (selectedSquare && validMoves.some(m => m.to === square)) {
                    const move = validMoves.find(m => m.to === square);
                    // Check if this is a promotion move
                    if (move && move.flags.includes('p')) {
                        setPromotionDialog({ from: selectedSquare, to: square });
                        return;
                    }
                    const capturedPiece = game.get(square);
                    const result = game.move({ from: selectedSquare, to: square });
                    if (result) {
                        setLastMove({ from: selectedSquare, to: square });
                        playSound(capturedPiece ? 'capture' : 'move');
                    }
                    setSelectedSquare(null);
                    setValidMoves([]);
                    setHintMove(null);
                    syncState();
                    return;
                }
                const piece = game.get(square);
                if (piece && piece.color === game.turn()) {
                    setSelectedSquare(square);
                    setValidMoves(game.moves({ square, verbose: true }));
                } else {
                    setSelectedSquare(null);
                    setValidMoves([]);
                }
            };

            const handlePromotion = (piece) => {
                if (!promotionDialog) return;
                const game = gameRef.current;
                const capturedPiece = game.get(promotionDialog.to);
                const result = game.move({ from: promotionDialog.from, to: promotionDialog.to, promotion: piece });
                if (result) {
                    setLastMove({ from: promotionDialog.from, to: promotionDialog.to });
                    playSound(capturedPiece ? 'capture' : 'move');
                }
                setPromotionDialog(null);
                setSelectedSquare(null);
                setValidMoves([]);
                setHintMove(null);
                syncState();
            };

            const requestHint = () => {
                const game = gameRef.current;
                if (!engineReady) return;
                getEngineBestMove(game, Math.max(1, aiDepth - 1)).then(moveStr => {
                    setHintMove(moveStr ? { from: moveStr.slice(0, 2), to: moveStr.slice(2, 4) } : null);
                });
            };

            const undoMove = () => {
                const game = gameRef.current;
                if (game.history().length === 0) return;
                game.undo();
                if (mode === 'ai' && game.turn() === aiSide && game.history().length > 0) {
                    game.undo();
                }
                setSelectedSquare(null);
                setValidMoves([]);
                setHintMove(null);
                setLastMove(null);
                syncState();
            };

            useEffect(() => {
                if (mode === 'ai' && gameStatus === 'playing' && gameRef.current.turn() === aiSide && !aiThinking && engineReady) {
                    setAiThinking(true);
                    getEngineBestMove(gameRef.current, aiDepth).then(moveStr => {
                        if (moveStr) {
                            const from = moveStr.slice(0, 2);
                            const to = moveStr.slice(2, 4);
                            const capturedPiece = gameRef.current.get(to);
                            applyMoveString(gameRef.current, moveStr);
                            setLastMove({ from, to });
                            playSound(capturedPiece ? 'capture' : 'move');
                            setHintMove(null);
                            syncState();
                        }
                        setAiThinking(false);
                    }).catch(() => {
                        setEngineError('Engine failed; try reloading.');
                        setAiThinking(false);
                    });
                }
            }, [board, mode, aiSide, aiDepth, gameStatus, aiThinking, engineReady]);

            useEffect(() => {
                if (mode === 'human' && aiThinking) setAiThinking(false);
            }, [mode]);

            useEffect(() => {
                loadLeaderboard();
            }, []);

            useEffect(() => {
                const worker = new Worker('https://cdn.jsdelivr.net/npm/stockfish@16.0.0/src/stockfish-nnue-16-single.js');
                engineRef.current = worker;
                const handleMessage = (event) => {
                    const line = event.data;
                    if (typeof line !== 'string') return;
                    if (line === 'uciok' || line === 'readyok') setEngineReady(true);
                    if (line.startsWith('Unknown') || line.startsWith('info string ERROR')) {
                        setEngineError(line);
                    }
                };
                worker.addEventListener('message', handleMessage);
                worker.postMessage('uci');
                worker.postMessage('isready');
                return () => {
                    worker.removeEventListener('message', handleMessage);
                    worker.terminate();
                };
            }, []);

            const getEngineBestMove = (game, depth) => {
                return new Promise((resolve, reject) => {
                    const worker = engineRef.current;
                    if (!worker) return reject(new Error('Engine missing'));
                    const fen = game.fen();
                    const handleMessage = (event) => {
                        const line = event.data;
                        if (typeof line !== 'string') return;
                        if (line.startsWith('bestmove')) {
                            worker.removeEventListener('message', handleMessage);
                            const moveStr = line.split(' ')[1];
                            resolve(moveStr || null);
                        }
                    };
                    worker.addEventListener('message', handleMessage);
                    try {
                        worker.postMessage('stop');
                        worker.postMessage('ucinewgame');
                        worker.postMessage(`position fen ${fen}`);
                        worker.postMessage(`go depth ${depth}`);
                    } catch (err) {
                        worker.removeEventListener('message', handleMessage);
                        reject(err);
                    }
                });
            };

            const statusText = useMemo(() => {
                if (gameStatus === 'playing') {
                    const turnText = turn === 'w' ? 'White' : 'Black';
                    const inCheck = gameRef.current.in_check();
                    return `${turnText} to move${inCheck ? ' ‚Ä¢ CHECK' : ''}`;
                }
                return formatStatus(gameStatus);
            }, [gameStatus, turn]);

            return (
                <div className="min-h-screen bg-slate-900 text-slate-100 p-4">
                    <div className="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-8">
                        <div className="lg:col-span-2 flex flex-col items-center">
                            <div className="text-center mb-4">
                                <h1 className="text-4xl font-black tracking-tighter text-white mb-2">ATLAS CHESS</h1>
                                <p className="text-slate-400 text-sm">Play against a friend or challenge our built-in AI.</p>
                            </div>

                            {/* Captured pieces - White */}
                            <div className="flex gap-1 items-center justify-center mb-2 h-8">
                                {capturedPieces.w.map((type, i) => (
                                    <span key={i} className="text-2xl text-white drop-shadow">{pieceIcons.w[type]}</span>
                                ))}
                            </div>

                            <div className="bg-slate-800 p-2 rounded-lg shadow-2xl border-4 border-slate-700 relative">
                                <div className="grid grid-cols-8 w-full max-w-[520px] aspect-square">
                                    {board.map((row, r) => row.map((piece, c) => {
                                        const displayR = flipped ? 7 - r : r;
                                        const displayC = flipped ? 7 - c : c;
                                        const actualRow = board[displayR];
                                        const actualPiece = actualRow ? actualRow[displayC] : null;
                                        const isLight = (displayR + displayC) % 2 === 0;
                                        const square = squareName(displayR, displayC);
                                        const isSelected = selectedSquare === square;
                                        const isValid = validMoves.some(m => m.to === square);
                                        const isHint = hintMove && (hintMove.from === square || hintMove.to === square);
                                        const isLastMove = lastMove && (lastMove.from === square || lastMove.to === square);
                                        return (
                                            <button
                                                key={`${r}-${c}`}
                                                onClick={() => handleSquareClick(square)}
                                                className={`relative aspect-square flex items-center justify-center text-4xl transition-all border border-slate-800 ${isLight ? 'bg-slate-200' : 'bg-slate-600'} ${isSelected ? 'ring-4 ring-amber-400' : ''} ${isHint ? 'outline outline-4 outline-sky-400/70' : ''} ${isLastMove ? 'bg-yellow-300/40 square-highlight' : ''}`}
                                            >
                                                {isValid && <span className="absolute w-3 h-3 bg-emerald-400 rounded-full opacity-90"></span>}
                                                {actualPiece && <span className={`${actualPiece.color === 'w' ? 'text-white drop-shadow' : 'text-slate-900 drop-shadow'} ${isLastMove ? 'piece-animation' : ''}`}>{pieceIcons[actualPiece.color][actualPiece.type]}</span>}
                                            </button>
                                        );
                                    }))}
                                </div>

                                {/* Promotion Dialog */}
                                {promotionDialog && (
                                    <div className="absolute inset-0 bg-black/80 flex items-center justify-center rounded-lg">
                                        <div className="bg-slate-800 p-6 rounded-xl border-4 border-amber-400">
                                            <h3 className="text-xl font-bold mb-4 text-center">Choose Promotion</h3>
                                            <div className="flex gap-3">
                                                {['q', 'r', 'b', 'n'].map(p => (
                                                    <button
                                                        key={p}
                                                        onClick={() => handlePromotion(p)}
                                                        className="bg-slate-700 hover:bg-slate-600 p-4 rounded-lg text-5xl transition-colors"
                                                    >
                                                        <span className={gameRef.current.turn() === 'w' ? 'text-white' : 'text-slate-900'}>{pieceIcons[gameRef.current.turn()][p]}</span>
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>

                            {/* Captured pieces - Black */}
                            <div className="flex gap-1 items-center justify-center mt-2 h-8">
                                {capturedPieces.b.map((type, i) => (
                                    <span key={i} className="text-2xl text-slate-900 drop-shadow">{pieceIcons.b[type]}</span>
                                ))}
                            </div>

                            <div className="flex flex-wrap gap-3 mt-5 justify-center">
                                <button onClick={resetGame} className="flex items-center gap-2 bg-indigo-600 hover:bg-indigo-500 px-5 py-3 rounded-xl font-bold transition-colors">
                                    <Icon name="rotate-ccw" /> New Game
                                </button>
                                <button onClick={undoMove} className="flex items-center gap-2 bg-slate-700 hover:bg-slate-600 px-4 py-3 rounded-xl font-semibold">
                                    <Icon name="undo-2" /> Undo
                                </button>
                                <button onClick={requestHint} disabled={aiThinking || gameStatus !== 'playing'} className={`flex items-center gap-2 px-4 py-3 rounded-xl font-semibold ${aiThinking || gameStatus !== 'playing' ? 'bg-slate-700 text-slate-400' : 'bg-emerald-600 hover:bg-emerald-500'}`}>
                                    <Icon name="sparkles" /> Hint
                                </button>
                                <button onClick={() => setFlipped(!flipped)} className="flex items-center gap-2 bg-purple-600 hover:bg-purple-500 px-4 py-3 rounded-xl font-semibold">
                                    <Icon name="flip-vertical" /> Flip
                                </button>
                                {gameStatus === 'playing' && (
                                    <button onClick={resign} className="flex items-center gap-2 bg-red-600 hover:bg-red-500 px-4 py-3 rounded-xl font-semibold">
                                        <Icon name="flag" /> Resign
                                    </button>
                                )}
                                {gameStatus !== 'playing' && (
                                    <button onClick={() => navigator.share ? navigator.share({ text: 'Just played Atlas Chess!' }) : window.open('https://twitter.com/intent/tweet?text=Just%20played%20Atlas%20Chess!', '_blank')} className="flex items-center gap-2 bg-sky-500 hover:bg-sky-400 px-5 py-3 rounded-xl font-bold">
                                        <Icon name="share-2" /> Share
                                    </button>
                                )}
                            </div>
                        </div>

                        <div className="space-y-4">
                            <div className="bg-slate-800 p-5 rounded-2xl border border-slate-700">
                                <h3 className="text-xl font-bold flex items-center gap-2 mb-3"><Icon name="cpu" /> Mode</h3>
                                <div className="flex flex-col gap-3">
                                    <div className="flex items-center justify-between bg-slate-900 p-3 rounded-xl border border-slate-700">
                                        <span className="font-semibold">Opponent</span>
                                        <div className="flex gap-2">
                                            <button onClick={() => { setMode('human'); resetGame(); }} className={`px-3 py-2 rounded-lg text-sm font-bold ${mode === 'human' ? 'bg-emerald-600' : 'bg-slate-700'}`}>Human</button>
                                            <button onClick={() => { setMode('ai'); resetGame(); }} className={`px-3 py-2 rounded-lg text-sm font-bold ${mode === 'ai' ? 'bg-emerald-600' : 'bg-slate-700'}`}>AI</button>
                                        </div>
                                    </div>
                                    {mode === 'ai' && (
                                        <>
                                            <div className="flex items-center justify-between bg-slate-900 p-3 rounded-xl border border-slate-700">
                                                <span className="font-semibold">AI Plays</span>
                                                <div className="flex gap-2">
                                                    <button onClick={() => { setAiSide('w'); resetGame(); }} className={`px-3 py-2 rounded-lg text-sm font-bold ${aiSide === 'w' ? 'bg-indigo-500' : 'bg-slate-700'}`}>White</button>
                                                    <button onClick={() => { setAiSide('b'); resetGame(); }} className={`px-3 py-2 rounded-lg text-sm font-bold ${aiSide === 'b' ? 'bg-indigo-500' : 'bg-slate-700'}`}>Black</button>
                                                </div>
                                            </div>
                                            <div className="bg-slate-900 p-3 rounded-xl border border-slate-700">
                                                <div className="flex justify-between items-center mb-2">
                                                    <span className="font-semibold">Difficulty</span>
                                                </div>
                                                <div className="grid grid-cols-2 gap-2">
                                                    <button onClick={() => setAiDepth(1)} className={`px-3 py-2 rounded-lg text-sm font-semibold ${aiDepth === 1 ? 'bg-green-600' : 'bg-slate-700'}`}>
                                                        Beginner
                                                    </button>
                                                    <button onClick={() => setAiDepth(2)} className={`px-3 py-2 rounded-lg text-sm font-semibold ${aiDepth === 2 ? 'bg-yellow-600' : 'bg-slate-700'}`}>
                                                        Easy
                                                    </button>
                                                    <button onClick={() => setAiDepth(3)} className={`px-3 py-2 rounded-lg text-sm font-semibold ${aiDepth === 3 ? 'bg-orange-600' : 'bg-slate-700'}`}>
                                                        Medium
                                                    </button>
                                                    <button onClick={() => setAiDepth(5)} className={`px-3 py-2 rounded-lg text-sm font-semibold ${aiDepth === 5 ? 'bg-red-600' : 'bg-slate-700'}`}>
                                                        Hard
                                                    </button>
                                                </div>
                                                <p className="text-xs text-slate-400 mt-2">Depth: {aiDepth} ‚Ä¢ Higher = stronger but slower</p>
                                            </div>
                                        </>
                                    )}
                                    <div className="bg-slate-900 p-3 rounded-xl border border-slate-700 flex items-center justify-between">
                                        <div>
                                            <p className="text-sm text-slate-400">Status</p>
                                            <p className="font-bold text-lg">{statusText}</p>
                                            {mode === 'ai' && !engineReady && <p className="text-xs text-amber-400">Loading Stockfish‚Ä¶</p>}
                                            {engineError && <p className="text-xs text-red-400">{engineError}</p>}
                                        </div>
                                        {aiThinking && <span className="text-amber-400 text-sm flex items-center gap-1"><Icon name="loader-2" className="animate-spin" /> AI thinking‚Ä¶</span>}
                                    </div>
                                    <div className="bg-slate-900 p-3 rounded-xl border border-slate-700 flex items-center justify-between">
                                        <span className="font-semibold">Sound Effects</span>
                                        <button onClick={() => setSoundEnabled(!soundEnabled)} className={`px-3 py-2 rounded-lg text-sm font-bold ${soundEnabled ? 'bg-emerald-600' : 'bg-slate-700'}`}>
                                            {soundEnabled ? <Icon name="volume-2" /> : <Icon name="volume-x" />}
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div className="bg-slate-800 p-5 rounded-2xl border border-slate-700">
                                <h3 className="text-xl font-bold flex items-center gap-2 mb-3"><Icon name="list-ordered" /> Moves</h3>
                                <div className="max-h-52 overflow-y-auto pr-2 space-y-2 text-sm">
                                    {moveHistory.length === 0 && <p className="text-slate-500 italic">No moves yet</p>}
                                    {moveHistory.map((m, i) => (
                                        <div key={i} className="flex items-center justify-between bg-slate-900 px-3 py-2 rounded-lg border border-slate-800">
                                            <span className="text-slate-300">{Math.floor(i / 2) + 1}{i % 2 === 0 ? '.' : '...'} {m}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            <div className="bg-slate-800 p-5 rounded-2xl border border-slate-700">
                                <h3 className="text-xl font-bold flex items-center gap-2 mb-3">
                                    <Icon name="trophy" /> Leaderboard
                                    {SUPABASE_URL !== 'YOUR_SUPABASE_URL' && <span className="text-xs text-emerald-400 font-normal">üåê Live</span>}
                                </h3>
                                <div className="space-y-2 max-h-48 overflow-y-auto pr-2">
                                    {loadingLeaderboard && <p className="text-slate-500 italic text-sm">Loading...</p>}
                                    {!loadingLeaderboard && leaderboard.length === 0 && <p className="text-slate-500 italic text-sm">No completed games yet</p>}
                                    {!loadingLeaderboard && leaderboard.map((entry, i) => (
                                        <div key={i} className="bg-slate-900 p-3 rounded-lg border border-slate-800 text-sm flex justify-between">
                                            <div>
                                                <p className="font-semibold">{entry.winner} wins</p>
                                                <p className="text-slate-400">{entry.mode === 'ai' ? `vs AI (${entry.ai_side || entry.aiSide}, d${entry.depth})` : 'Human vs Human'}</p>
                                            </div>
                                            <div className="text-right text-slate-400">
                                                <p>{entry.moves} moves</p>
                                                <p className="text-xs">{entry.date || new Date(entry.created_at).toLocaleString()}</p>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>
                    <div className="max-w-6xl mx-auto mt-6">
                        <div className="bg-amber-900/40 border border-amber-700/60 rounded-2xl p-4 md:p-5 text-sm text-amber-100 shadow-xl backdrop-blur">
                            <div className="flex items-start gap-3">
                                <span className="mt-1 inline-flex h-8 w-8 items-center justify-center rounded-full bg-amber-700/60">
                                    <Icon name="shield-alert" />
                                </span>
                                <div className="space-y-2">
                                    <p className="font-bold text-amber-200">Parody & Safety Notice</p>
                                    <ul className="list-disc pl-5 space-y-1 text-amber-100/90">
                                        <li>Atlas Chess is a playful, parody project for fun and experimentation; it is not a real scoring or surveillance tool.</li>
                                        <li>Numbers, ratings, and leaderboard entries may be incomplete, experimental, or inaccurate‚Äîdo not rely on them for decisions about real people.</li>
                                        <li>Content and gameplay are for entertainment only and do not constitute legal, financial, employment, or any other professional advice.</li>
                                        <li>We are not affiliated with any chess federation, employer, government, or monitoring program; any resemblance to real systems is coincidental.</li>
                                    </ul>
                                    <p className="text-amber-200/80">By continuing you agree to treat this as parody entertainment and not to use it to assess, rank, or make real-world decisions about anyone.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ChessGame />);
    </script>
</body>
</html>
